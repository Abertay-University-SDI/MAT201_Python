
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. More 3D Coordinate Transformations &#8212; MAT201 Applied Mathematics with Python</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Complex Numbers" href="MAT201M_ComplexNos.html" />
    <link rel="prev" title="2. Coordinate Transformations in 3D" href="MAT201M_3DVT.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/Abertay_Uni_Black.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">MAT201 Applied Mathematics with Python</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../MAT201_PythonIntro.html">
   Python Introduction
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Dynamics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamics/MAT201D_AccVelDist.html">
   1. Linear Motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamics/MAT201D_AirRes.html">
   2. Air Resistance
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamics/MAT201D_SHM.html">
   3. Simple Harmonic Motion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamics/MAT201D_2DSWcols.html">
   4. 2D Sphere/Wall Collisions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../dynamics/MAT201D_2DSScols.html">
   5. 2D Sphere/Sphere Collisions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Methods
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_2DVT.html">
   1. 2D Viewing Transforms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_3DVT.html">
   2. 3D Viewing Transforms
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   3. More 3D Viewing Transforms
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_ComplexNos.html">
   4. Complex Numbers
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_Quats.html">
   5. Quaternions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_RaysIntro.html">
   6. Ray Tracing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_RaysBoxes.html">
   7. Rays and Boxes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="MAT201M_RaysPlanes.html">
   8. Rays and Planes
  </a>
 </li>
</ul>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../outro.html">
   Summary
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/methods/MAT201M_3DVT2.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/Abertay-University-SDI/MAT201_Python"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/Abertay-University-SDI/MAT201_Python/issues/new?title=Issue%20on%20page%20%2Fmethods/MAT201M_3DVT2.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/Abertay-University-SDI/MAT201_Python/main?urlpath=lab/tree/methods/MAT201M_3DVT2.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/Abertay-University-SDI/MAT201_Python/blob/main/methods/MAT201M_3DVT2.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mirror-reflection-in-a-given-plane">
   3.1. Mirror reflection in a given plane
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lecture-example">
     3.1.1. Lecture Example:
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rotation-about-an-arbitrary-axis">
   3.2. Rotation about an arbitrary axis
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lecture-example-rotating-a-pyramid">
     3.2.1. Lecture example: Rotating a pyramid
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#part-2-rotation-about-axis-not-at-origin">
     3.2.2. Part 2: Rotation about axis not at origin
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#over-to-you">
   3.3. Over to you
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>More 3D Coordinate Transformations</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mirror-reflection-in-a-given-plane">
   3.1. Mirror reflection in a given plane
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lecture-example">
     3.1.1. Lecture Example:
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#rotation-about-an-arbitrary-axis">
   3.2. Rotation about an arbitrary axis
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#lecture-example-rotating-a-pyramid">
     3.2.1. Lecture example: Rotating a pyramid
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#part-2-rotation-about-axis-not-at-origin">
     3.2.2. Part 2: Rotation about axis not at origin
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#over-to-you">
   3.3. Over to you
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="more-3d-coordinate-transformations">
<h1><span class="section-number">3. </span>More 3D Coordinate Transformations<a class="headerlink" href="#more-3d-coordinate-transformations" title="Permalink to this headline">¶</a></h1>
<p>We have already shown how Python is capable of performing and visualising the standard set of operations for 3D graphics transformations.</p>
<p>There are several additional useful operations than can be performed by matrices. This notebook will examine two of these: <em>reflection in a given plane</em> and <em>rotation about an axis</em>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>## Libraries
import numpy as np
import math 
import matplotlib.pyplot as plt
import sympy as sym
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.patches import FancyArrowPatch
from mpl_toolkits.mplot3d import proj3d
</pre></div>
</div>
</div>
</div>
<div class="section" id="mirror-reflection-in-a-given-plane">
<h2><span class="section-number">3.1. </span>Mirror reflection in a given plane<a class="headerlink" href="#mirror-reflection-in-a-given-plane" title="Permalink to this headline">¶</a></h2>
<p>We have been shown in the lectures that reflecting an object in the plane <span class="math notranslate nohighlight">\( ax+by+cz=0\)</span> can be performed by multiplying a set of homogenous coordinates by the reflection matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}
M_{\rm{reflection}} = 
	{\begin{pmatrix}
	-a^2+b^2+c^2 &amp; -2ab &amp; -2ac &amp; 0  \\
	-2ab &amp; a^2-b^2+c^2 &amp; -2bc &amp; 0  \\
	-2ac &amp; -2bc &amp; a^2+b^2-c^2 &amp; 0  \\
	0 &amp; 0 &amp; 0 &amp; a^2+b^2+c^2 
	\end{pmatrix}}.
\end{split}\]</div>
<p>The additional factor of <span class="math notranslate nohighlight">\(a^2+b^2+c^2\)</span> in the bottom right element of this matrix means that we must remember to check that we have returned to homogenous coordinates after the calculation has been carried out.</p>
<p>To test this, we will repeat one of the examples shown in the lectures:</p>
<div class="section" id="lecture-example">
<h3><span class="section-number">3.1.1. </span>Lecture Example:<a class="headerlink" href="#lecture-example" title="Permalink to this headline">¶</a></h3>
<p><strong>Calculate the images of the points <span class="math notranslate nohighlight">\((3,2,1)\)</span> and <span class="math notranslate nohighlight">\((-1,0,1)\)</span> when reflected in the plane <span class="math notranslate nohighlight">\(2x+y-3z=4\)</span></strong>.</p>
<p>Let’s set up a matrix of positions that we can transform.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x_vals = np.array([3, -1])
y_vals = np.array([2, 0])
z_vals = np.array([1, 1])
p = np.array([x_vals, y_vals, z_vals])
</pre></div>
</div>
</div>
</div>
<p>Before we perform the transformation, let’s plot the two positions and (because we can) draw a line between the two points:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>lx=np.append(x_vals,x_vals[0]) #drawing the line between the last and first coord
ly=np.append(y_vals,y_vals[0])
lz=np.append(z_vals,z_vals[0])
ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
ax.view_init(elev=20, azim=315, roll=0)
ax.plot(lx, ly, lz, &#39;ko&#39;, linestyle=&quot;--&quot;)
ax.plot(x_vals, y_vals, z_vals, &#39;ko&#39;)
ax.text(lx[0]-1, ly[0]+1, lz[0]+1, &quot;A&quot;, c=&#39;k&#39;)
ax.text(lx[1]-1, ly[1]+1, lz[1]+1, &quot;B&quot;, c=&#39;k&#39;)
ax.set_xlabel(&#39;x&#39;)
ax.set_ylabel(&#39;y&#39;)
ax.set_zlabel(&#39;z&#39;)
ax.axes.set_xlim3d(left=-5, right=5) 
ax.axes.set_ylim3d(bottom=0, top=10) 
ax.axes.set_zlim3d(bottom=-5, top=5)
plt.gca().set_aspect(&#39;equal&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/MAT201M_3DVT2_6_0.png" src="../_images/MAT201M_3DVT2_6_0.png" />
</div>
</div>
<p>When using Python this way, we need to remember i) to convert our arrays into the correct shape vector and ii) to include homogenous coordinates. In this case, rather than specifying the number of 1’s needed, I will use Python to count the number of coordinate locations and produce an array of the same length. This new array is initialised by “1” in each element: this saves me having to do this manually, and can be extended easily if we introduce more coordinates into the problem.</p>
<p>Thus we can create our matrix of coordinates, formatted in the same way shown in class:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>nr = [1 for x in range(len(x_vals))]
hp = np.vstack([p, nr])
print(hp.transpose())
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 3  2  1  1]
 [-1  0  1  1]]
</pre></div>
</div>
</div>
</div>
<p>Now we can turn our attention to the reflection matrix.</p>
<p>We can only perform the calculation if the plane passes through the origin. A quick way to check is to see if the origin coordinates satisfy the plane equation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>a = 2
b = 1
c = -3
d = 4
print(&quot;LHS:&quot;, a*0+b*0+c*0)
print(&quot;RHS:&quot;, d)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>LHS: 0
RHS: 4
</pre></div>
</div>
</div>
</div>
<p>Since the left and right hand sides of the plane equations do not match, the origin is not a solution of this equation. This means we need to translate our points, using the translation matrix we discussed previously:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
T_{\underline{w}} = 
	{\begin{pmatrix}
	1 &amp; 0 &amp; 0 &amp; 0  \\
	0 &amp; 1 &amp; 0 &amp; 0  \\
	0 &amp; 0 &amp; 1 &amp; 0  \\
	a_x &amp; a_y &amp; a_z &amp; 1 
	\end{pmatrix}},
\end{split}\]</div>
<p>To identify the amount we need to move, we can rearrange the plane equation, so that if we choose some points for <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, the equation will determine values of z:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x1 = 1.
y1 = 2.
z1 = (a * x1 + b * y1 - d) / c
print(x1,y1,z1,&quot; lies on plane&quot;)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0 2.0 -0.0  lies on plane
</pre></div>
</div>
</div>
</div>
<p>This is the amount we will translate by (and while we are at it, we might as well create the opposite transformation that we’ll have to use at the end too).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Tw = np.matrix([[1, 0, 0, 0], 
                [0, 1, 0, 0], 
                [0, 0, 1, 0],
                [-x1,-y1, -z1, 1]])
Tv = np.matrix([[1, 0, 0, 0], 
                [0, 1, 0, 0], 
                [0, 0, 1, 0],
                [x1, y1, z1, 1]])
</pre></div>
</div>
</div>
</div>
<p>Now we can create our reflection matrix from the formula:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Mr = np.matrix([[-a*a+b*b+c*c, -2*a*b, -2*a*c, 0], 
                [-2*a*b, a*a-b*b+c*c, -2*b*c, 0], 
                [-2*a*c, -2*b*c, a*a+b*b-c*c, 0],
                [0,0, 0, a*a+b*b+c*c]])
</pre></div>
</div>
</div>
</div>
<p>We’ve formed all the pieces that will allow us to perform the reflection in full, so let’s go ahead and apply them to our coordinates:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>rp = hp.transpose()*Tw*Mr*Tv
print(rp)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 38.  26.  20.  14.]
 [ 22.  18. -40.  14.]]
</pre></div>
</div>
</div>
</div>
<p>Following the transformation, we note that the final column (our homogenous coordinates) contain something other than one. This means we need to divide <em>all</em> coordinates in that row by the element in the final column, such that they become equal to one.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>rph = rp/rp[:,3:]
print(rph)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 2.71428571  1.85714286  1.42857143  1.        ]
 [ 1.57142857  1.28571429 -2.85714286  1.        ]]
</pre></div>
</div>
</div>
</div>
<p>These are the locations of the reflected image in homogenous coordinates.</p>
<p>Finally, to demonstrate the power of Python, we can plot the solution we have found. For completeness, I will include the plane about which the reflection is performed and the original (unreflected) positions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>newp = rph[:,0:3].transpose()
x_vals1 = np.squeeze(np.asarray(newp[0,:]))
y_vals1 = np.squeeze(np.asarray(newp[1,:]))
z_vals1 = np.squeeze(np.asarray(newp[2,:]))
slx=np.append(x_vals1,x_vals1[0])
sly=np.append(y_vals1,y_vals1[0])
slz=np.append(z_vals1,z_vals1[0])
xr = [-5,5]
yr = [0,10]
zr = [-5,5]
ax.axes.set_xlim3d(left=xr[0], right=xr[1]) 
ax.axes.set_ylim3d(bottom=yr[0], top=yr[1]) 
ax.axes.set_zlim3d(bottom=zr[0], top=zr[1])
#need to set up mesh for plotting plane over range of x, y
x = np.linspace(xr[0],xr[1],50)
y = np.linspace(yr[0],yr[1],50)
X,Y = np.meshgrid(x,y)
Z = (d - a*X - b*Y) / c
ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
ax.view_init(elev=20, azim=315, roll=0)
ax.plot(lx, ly, lz, &#39;ko&#39;, linestyle=&quot;--&quot;)
ax.plot(x_vals, y_vals, z_vals, &#39;ko&#39;)
ax.plot(slx, sly, slz, &#39;ro&#39;, linestyle=&quot;--&quot;)
ax.plot(x_vals1, y_vals1, z_vals1, &#39;ro&#39;)
ax.set_xlabel(&#39;x&#39;)
ax.set_ylabel(&#39;y&#39;)
ax.set_zlabel(&#39;z&#39;)
surf = ax.plot_surface(X, Y, Z)
plt.gca().set_aspect(&#39;equal&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/MAT201M_3DVT2_22_0.png" src="../_images/MAT201M_3DVT2_22_0.png" />
</div>
</div>
<p>In this example the points we need to reflect actually straddle the plane: the reflected images therefore also straddle the plane, but in the opposite sense.</p>
</div>
</div>
<div class="section" id="rotation-about-an-arbitrary-axis">
<h2><span class="section-number">3.2. </span>Rotation about an arbitrary axis<a class="headerlink" href="#rotation-about-an-arbitrary-axis" title="Permalink to this headline">¶</a></h2>
<p>Another useful tool in our 3D transformation arsenal is the ability to rotate a point (or set of points) by a specified angle about a specified axis.</p>
<p>The formula required to carry out this operation is that shown in lectures (and also present in the formula book):</p>
<div class="math notranslate nohighlight">
\[\begin{split}
	{R_{\theta,\underline{\hat{v}}}=
	\begin{pmatrix}
	\alpha^2(1-\cos\theta)+\cos\theta &amp; \alpha\beta(1-\cos\theta)+\gamma\sin\theta &amp; \alpha\gamma(1-\cos\theta)-\beta\sin\theta &amp; 0   \\
	\alpha\beta(1-\cos\theta)-\gamma\sin\theta &amp; \beta^2(1-\cos\theta)+\cos\theta &amp; \beta\gamma(1-\cos\theta)+\alpha\sin\theta  &amp; 0 \\
	\alpha\gamma(1-\cos\theta)+\beta\sin\theta &amp; \beta\gamma(1-\cos\theta)-\alpha\sin\theta &amp; \gamma^2(1-\cos\theta)+\cos\theta &amp; 0 \\
	0 &amp; 0 &amp; 0 &amp; 1 
	\end{pmatrix}},
\end{split}\]</div>
<p>for a rotation by angle <span class="math notranslate nohighlight">\(\theta\)</span> about the unit vector <span class="math notranslate nohighlight">\({\vec{v}}=\alpha{\vec{i}}+\beta{\vec{j}}+\gamma{\vec{k}} \)</span>.</p>
<p>Let us examine the application of this matrix using another example from our lectures:</p>
<div class="section" id="lecture-example-rotating-a-pyramid">
<h3><span class="section-number">3.2.1. </span>Lecture example: Rotating a pyramid<a class="headerlink" href="#lecture-example-rotating-a-pyramid" title="Permalink to this headline">¶</a></h3>
<p><strong>The pyramid defined by coordinates <span class="math notranslate nohighlight">\(O(0,0,0), B(1,0,0), C(0,1,0)\)</span> and <span class="math notranslate nohighlight">\(D(0,0,1)\)</span> is rotated by <span class="math notranslate nohighlight">\(45^o\)</span> about the line that has direction <span class="math notranslate nohighlight">\(\vec{v}=\vec{j}+\vec{k}\)</span> and passes through:</strong></p>
<ol class="simple">
<li><p><strong>the origin;</strong></p></li>
<li><p><strong>the point C(0,1,0).</strong>
<strong>Obtain the vertices of the rotated figure in both cases.</strong></p></li>
</ol>
<hr class="docutils" />
<p>We will start by defining the coordinates specified in the question:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>O = [0,0,0]
B = [1,0,0]
C = [0,1,0]
D = [0,0,1]
x_vals2=[O[0],B[0],C[0],D[0]]
y_vals2=[O[1],B[1],C[1],D[1]]
z_vals2=[O[2],B[2],C[2],D[2]]
</pre></div>
</div>
</div>
</div>
<p>Let us first begin by establishing what the pyramid looks like prior to any rotation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>p2 = np.array([x_vals2, y_vals2, z_vals2])
ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
ax.view_init(elev=20, azim=30, roll=0)
ax.plot([O[0],C[0]], [O[1],C[1]], [O[2],C[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O[0],B[0]], [O[1],B[1]], [O[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O[0],D[0]], [O[1],D[1]], [O[2],D[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([C[0],B[0]], [C[1],B[1]], [C[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([C[0],D[0]], [C[1],D[1]], [C[2],D[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([D[0],B[0]], [D[1],B[1]], [D[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.set_xlabel(&#39;x&#39;)
ax.set_ylabel(&#39;y&#39;)
ax.set_zlabel(&#39;z&#39;)
ax.axes.set_xlim3d(left=-2, right=3) 
ax.axes.set_ylim3d(bottom=-2, top=3) 
ax.axes.set_zlim3d(bottom=-2, top=3)
plt.gca().set_aspect(&#39;equal&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/MAT201M_3DVT2_28_0.png" src="../_images/MAT201M_3DVT2_28_0.png" />
</div>
</div>
<p>Now let us examine the axis of rotation. In order to be in the correct format to use in the rotation matrix taught in the lectures, the axis of rotation must be framed as a unit vector.</p>
<p>In this case, I’m too lazy to check if the vector is unit or not: I’ll just divide the vector by it’s size (that way if the vector is already unit, dividing by its size won’t change the vector):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>v = [0,1,1]
v_hat = v / np.linalg.norm(v)
print(v_hat)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0.         0.70710678 0.70710678]
</pre></div>
</div>
</div>
</div>
<p>We now have all the ingredients we need to fill the abitrary rotation matrix. Remember that, in Python, arguments for trigonometric functions must be in radians:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>alpha = v_hat[0]
beta = v_hat[1]
gamma = v_hat[2]
theta = 45
st = np.sin(math.radians(theta))
ct = np.cos(math.radians(theta))
Rtv = np.matrix([[alpha*alpha*(1-ct)+ct, alpha*beta*(1-ct)+gamma*st, alpha*gamma*(1-ct)-beta*st, 0], 
                [alpha*beta*(1-ct)-gamma*st, beta*beta*(1-ct)+ct, beta*gamma*(1-ct)+alpha*st, 0], 
                [alpha*gamma*(1-ct)+beta*st, beta*gamma*(1-ct)-alpha*st, gamma*gamma*(1-ct)+ct, 0],
                [0,0, 0, 1]])
</pre></div>
</div>
</div>
</div>
<p>Now that the rotation is stored in the matrix, we can carry out the transformation of the points as before:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>nr2 = [1 for x in range(len(x_vals2))]
kp = np.vstack([p2, nr2])
print(&quot;original points:&quot;)
print(kp.transpose())
fp = kp.transpose()*Rtv
print(&quot;rotated points:&quot;)
print(fp)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>original points:
[[0 0 0 1]
 [1 0 0 1]
 [0 1 0 1]
 [0 0 1 1]]
rotated points:
[[ 0.          0.          0.          1.        ]
 [ 0.70710678  0.5        -0.5         1.        ]
 [-0.5         0.85355339  0.14644661  1.        ]
 [ 0.5         0.14644661  0.85355339  1.        ]]
</pre></div>
</div>
</div>
</div>
<p>Thus we have rotated the object, and have returned the rotated positions in homogenous coordinates.</p>
<p>We’ll convert these positions back to Cartesian coordinates ready for plotting:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>newp2 = fp[:,0:3].transpose()
x_vals2n = np.squeeze(np.asarray(newp2[0,:]))
y_vals2n = np.squeeze(np.asarray(newp2[1,:]))
z_vals2n = np.squeeze(np.asarray(newp2[2,:]))
O2 = np.squeeze(np.asarray(newp2[:,0]))
B2 = np.squeeze(np.asarray(newp2[:,1]))
C2 = np.squeeze(np.asarray(newp2[:,2]))
D2 = np.squeeze(np.asarray(newp2[:,3]))
</pre></div>
</div>
</div>
</div>
<p>Now we can look to visualise the result. First I will set up some custom arrows for Python to plot: we want to identify the vector about which the rotation is performed.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class Arrow3D(FancyArrowPatch):
    def __init__(self, xs, ys, zs, *args, **kwargs):
        super().__init__((0,0), (0,0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def do_3d_projection(self, renderer=None):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)
        self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        return np.min(zs)
</pre></div>
</div>
</div>
</div>
<p>The plot setup will build on what we have used before. We will include the original pyramid shape (black), and its rotated equivalent (red), plus a blue arrow denoting the axis of rotation:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
ax.view_init(elev=20, azim=30, roll=0)
ax.plot([O[0],B[0]], [O[1],B[1]], [O[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O[0],C[0]], [O[1],C[1]], [O[2],C[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O[0],D[0]], [O[1],D[1]], [O[2],D[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([C[0],B[0]], [C[1],B[1]], [C[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([D[0],B[0]], [D[1],B[1]], [D[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([C[0],D[0]], [C[1],D[1]], [C[2],D[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O2[0],C2[0]], [O2[1],C2[1]], [O2[2],C2[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([O2[0],B2[0]], [O2[1],B2[1]], [O2[2],B2[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([O2[0],D2[0]], [O2[1],D2[1]], [O2[2],D2[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([C2[0],B2[0]], [C2[1],B2[1]], [C2[2],B2[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([C2[0],D2[0]], [C2[1],D2[1]], [C2[2],D2[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([D2[0],B2[0]], [D2[1],B2[1]], [D2[2],B2[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.set_xlabel(&#39;x&#39;)
ax.set_ylabel(&#39;y&#39;)
ax.set_zlabel(&#39;z&#39;)
vstring=&quot;{}i+{}j+{}k&quot;.format(v[0],v[1],v[2])
arrow_prop_dict = dict(mutation_scale=20, arrowstyle=&#39;-|&gt;&#39;, color=&#39;b&#39;, shrinkA=0, shrinkB=0, linewidth=2)
a = Arrow3D([-3*v[0], 3*v[0]], [-3*v[1], 3*v[1]], [-3*v[2], 3*v[2]], **arrow_prop_dict)
ax.text(v[0], v[1], v[2], vstring, c=&#39;b&#39;)
ax.add_artist(a)
ax.axes.set_xlim3d(left=-2, right=3) 
ax.axes.set_ylim3d(bottom=-2, top=3) 
ax.axes.set_zlim3d(bottom=-2, top=3)
plt.gca().set_aspect(&#39;equal&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/MAT201M_3DVT2_40_0.png" src="../_images/MAT201M_3DVT2_40_0.png" />
</div>
</div>
<p>As in previous 3D examples, it is difficult to confirm the rotation has been carried out successfully using still 3D images. Try varying the rotation angle of the problem, or the viewing angle in the plotting commands to verify the behaviour of the solution.</p>
</div>
<div class="section" id="part-2-rotation-about-axis-not-at-origin">
<h3><span class="section-number">3.2.2. </span>Part 2: Rotation about axis not at origin<a class="headerlink" href="#part-2-rotation-about-axis-not-at-origin" title="Permalink to this headline">¶</a></h3>
<p>With the axis of rotation no longer passing through the origin, we must translate the coordinates by a distance equal to the effective distance of the axis from the origin. However, and really quite nicely, we can <em>re-use</em> the matrix we already calculated for the rotation, and simply book-end it with the necessary translations:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>Tmp = np.matrix([[1, 0, 0, 0], 
                [0, 1, 0, 0], 
                [0, 0, 1, 0],
                [-C[0],-C[1], -C[2], 1]])
Tpp = np.matrix([[1, 0, 0, 0], 
                [0, 1, 0, 0], 
                [0, 0, 1, 0],
                [C[0], C[1], C[2], 1]])
fp3 = kp.transpose()*Tmp*Rtv*Tpp
print(fp3)
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0.5         0.14644661 -0.14644661  1.        ]
 [ 1.20710678  0.64644661 -0.64644661  1.        ]
 [ 0.          1.          0.          1.        ]
 [ 1.          0.29289322  0.70710678  1.        ]]
</pre></div>
</div>
</div>
</div>
<p>With this technique we have very quickly recovered the solutions we determined in the lecture example.</p>
<p>Again, let’s take advantage of the power of Python to visualise what this means. Remember that in this second example, the rotation axis passes through the point C, so we would expect that the pyramid rotates about C (while C itself remains unaffected).</p>
<p>Taking the coordinates we found above, we can transpose them and group them together to make a visual comparison with the pyramid we started with.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>newp3 = fp3[:,0:3].transpose()
x_vals3n = np.squeeze(np.asarray(newp3[0,:]))
y_vals3n = np.squeeze(np.asarray(newp3[1,:]))
z_vals3n = np.squeeze(np.asarray(newp3[2,:]))
O3 = np.squeeze(np.asarray(newp3[:,0]))
B3 = np.squeeze(np.asarray(newp3[:,1]))
C3 = np.squeeze(np.asarray(newp3[:,2]))
D3 = np.squeeze(np.asarray(newp3[:,3]))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.figure().add_subplot(projection=&#39;3d&#39;)
ax.view_init(elev=20, azim=240, roll=0)
ax.plot([O[0],B[0]], [O[1],B[1]], [O[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O[0],C[0]], [O[1],C[1]], [O[2],C[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O[0],D[0]], [O[1],D[1]], [O[2],D[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([C[0],B[0]], [C[1],B[1]], [C[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([D[0],B[0]], [D[1],B[1]], [D[2],B[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([C[0],D[0]], [C[1],D[1]], [C[2],D[2]], &#39;ko&#39;, linestyle=&#39;-&#39;)
ax.plot([O3[0],C3[0]], [O3[1],C3[1]], [O3[2],C3[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([O3[0],B3[0]], [O3[1],B3[1]], [O3[2],B3[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([O3[0],D3[0]], [O3[1],D3[1]], [O3[2],D3[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([C3[0],B3[0]], [C3[1],B3[1]], [C3[2],B3[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([C3[0],D3[0]], [C3[1],D3[1]], [C3[2],D3[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.plot([D3[0],B3[0]], [D3[1],B3[1]], [D3[2],B3[2]], &#39;ro&#39;, linestyle=&#39;-&#39;)
ax.set_xlabel(&#39;x&#39;)
ax.set_ylabel(&#39;y&#39;)
ax.set_zlabel(&#39;z&#39;)
vstring=&quot;C+{}i+{}j+{}k&quot;.format(v[0],v[1],v[2])
arrow_prop_dict = dict(mutation_scale=20, arrowstyle=&#39;-|&gt;&#39;, color=&#39;b&#39;, shrinkA=0, shrinkB=0, linewidth=2)
a = Arrow3D([C[0]-3*v[0], C[0]+3*v[0]], [C[1]-3*v[1], C[1]+3*v[1]], [C[2]-3*v[2], C[2]+3*v[2]], **arrow_prop_dict)
ax.text(v[0], v[1], v[2], vstring, c=&#39;b&#39;)
ax.add_artist(a)
ax.axes.set_xlim3d(left=-2, right=3) 
ax.axes.set_ylim3d(bottom=-2, top=3) 
ax.axes.set_zlim3d(bottom=-2, top=3)
plt.gca().set_aspect(&#39;equal&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/MAT201M_3DVT2_46_0.png" src="../_images/MAT201M_3DVT2_46_0.png" />
</div>
</div>
<p>In this final image I have adjusted the viewing angle to highlight that the rotation does appear to have been performed correctly: one of the points has not been rotated, while the others look to have been achieved by a rotation about the blue axis.</p>
</div>
</div>
<div class="section" id="over-to-you">
<h2><span class="section-number">3.3. </span>Over to you<a class="headerlink" href="#over-to-you" title="Permalink to this headline">¶</a></h2>
<p>As usual, I recommend that you apply these tools and visualisation techniques to some of the problems seen in the maths tutorial sheet. Can you use Python to confirm your approach to the matrix multiplication by hand? Can you visualise what some of the reflection or rotation questions produce and why?</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./methods"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="MAT201M_3DVT.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">2. </span>Coordinate Transformations in 3D</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="MAT201M_ComplexNos.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Complex Numbers</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By James Threlfall<br/>
    
        &copy; Copyright 2022.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>